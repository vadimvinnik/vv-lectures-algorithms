%
% Softheme internal lectures
%
% Algorithms and data structures
%
% (c) Vadim Vinnik, 2014
%
% vadim.vinnik@gmail.com
%

\documentclass[landscape]{slides}
\input{global.tex}

\begin{document}

\author{В.Ю.\,Винник}

\title{Алгоритмы и структуры данных\\
Часть~1}

\date{Softheme, 30.10.2014 н.э}

\maketitle

\begin{slide}
  Предмет этого цикла лекций:
  \begin{itemize}
      \item Алгоритмы решения типовых и важных на практике задач обработки данных;
      \item Методика создания эффективных и корректных алгоритмов: от разрозненных примеров к общим принципам;
      \item Асимптотические оценки времени работы алгоритма;
      \item Типовые структуры данных, подходящие для широкого класса практических задач и поддерживающие быстрые алгоритмы.
    \end{itemize}
\end{slide}

\begin{slide}
  Введение
  \begin{itemize}
    \item Многие современные программы не содержат нетривиальных алгоритмов~-- например, их функционирование сводится
      к формированию запросов к БД и выдаче результата с применением какого-то стиля визуального оформления.
    \item Если первые программы состояли на 99\% из вычислений и на 1\% из интерфейса, то сейчас это соотношение
      стремится к противоположному.
    \item Нельзя при этом сказать, что современные программы стали просты~-- центр сложности сместился с
      алгоритмов, заключённых внутри программы, на внешние интерфейсы к другим программам и к человеку.
    \item Однако существуют по-прежнему программы, работающие с большими объёмами данных при жёстких ограничениях на
      время отклика: поисковые системы, крупные социальные сети, САПР, системы электронного документооборота, управляющее ПО.
  \end{itemize}
\end{slide}

\begin{slide}
  Для разработки таких программ необходимо:
  \begin{itemize}
    \item Из множества известных структур данных и алгоритмов выбирать те, которые наилучшим образом отражают специфику задачи и
      обеспечивают нужные критерии качества;
    \item В случае необходимости изобретать новые структуры данных и алгоритмы.
    \item Для заданной структуры данных оценивать, какие операции над ней выполняются быстрее или медленнее по сравнению с
      другими структурами данных.
    \item Для заданного алгоритма оценивать время его работы и затраты памяти в наихудшем и среднем случае.
  \end{itemize}
\end{slide}

\begin{slide}
  Важные уточнения
  \begin{itemize}
    \item В контексте этих лекций алгоритмы и структуры данных образуют неразрывную пару.
    \item Структара данных имеет смысл только потому, что программа может выполнять над ней определённые операции,
      необходимые для решения прикладных задач;
    \item Описание алгоритма всегда включает в себя определение форматов входных и выходных данных, т.е. алгоритм всегда
      привязан к некоторой структуре данных.
  \end{itemize}
\end{slide}

\begin{slide}
  О временн\'{о}й сложности
  \begin{itemize}
    \item Нужно измерять и сравнивать время работы алгоритмов.
    \item Физическое время в секундах работы алгоритма на конкретном процессоре~-- не подходит:
      процессоры отличаются тактовой частотой, степенью распараллеливания потока команд, аппаратным ускорением
      отдельных команд или их сочетаний.
    \item Выход: измерять количество шагов машины Тьюринга (или другой абстрактной машины с хорошо определённой семантикой
      элементарных операций) или количество важных операций (сравнений, присваиваний), если алгоритм выражен на языке
      высокого уровня.
  \end{itemize}
\end{slide}

\begin{slide}
  О временн\'{о}й сложности
  \begin{itemize}
    \item Время работы алгоритма на конкретном примере входных данных~-- не показатель. Из него нельзя сделать
      вывод о предпочтительности того или иного алгоритма для применения в реальной системе, где входные данные
      варьируются в широком классе возможных значений.
    \item Выход: сравнивать \emph{асимптотику} времени работы алгоритма как функции от входных данных.
      Например: $f(n)=a\,n^2$ при достаточно больших~$n$ растёт быстрее, чем $g(n)=b\,n\log n$, каковы бы ни были~$a,b>0$:
      \[
        \lim_{n \to \infty} \frac{a\,n^2}{b\,n\log n} = \infty .
      \]
      Поэтому пузырьковый алгоритм сортировки, который в массиве из~$n$ элементов проводит сравнение каждого элемента
      с каждым из оставшихся, следует считать более медленным, чем пирамидальный, в котором каждое сравнение отсекает
      от сравнения половину элементов.
  \end{itemize}
\end{slide}

\begin{slide}
  \begin{tabular}{|c|c|c|}
    \hline
    $f\in\ldots$ &
    Название &
    Определение
    \\
    \hline
    $O(g)$&
    ограниченность сверху&
    $\exists c>0, t \forall x>t\ f(x) \leqslant c\,g(x)$
    \\
    \hline
    $o(g)$&
    доминирование&
    $\exists c>0, t \forall x>t\ f(x) \leqslant c\,g(x)$
  \end{tabular}
\end{slide}
\end{document}

