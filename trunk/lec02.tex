%
% Softheme internal lectures
%
% Algorithms and data structures
%
% (c) Vadim Vinnik, 2014
%
% vadim.vinnik@gmail.com
%

\documentclass[landscape]{slides}
\input{global.tex}

\begin{document}

\author{В.Ю.\,Винник}

\title{Алгоритмы и структуры данных\\
Часть~2: Сортировка массивов}

\date{Softheme, 30.10.2014 н.э}

\maketitle

\begin{slide}
  Классификация алгоритмов внутренней сортировки массивов\\сравнением
  \begin{center}
    \renewcommand{\arraystretch}{2}
    \begin{tabular}{|l|l|l|}
      \hline
      {}&
      Простой&
      Улучшенный
      \\
      \hline
      Вставка&
      Простая вставка $O(n^2)$&
      Шелла\textonesuperior{} $O(n\log^2n)$, $O(n^\frac{3}{2})$
      \\
      \hline
      Выборка&
      Простая выборка $O(n^2)$&
      Heapsort $O(n\log n)$
      \\
      \hline
      Обмен&
      Пузырьковая $O(n^2)$&
      Quicksort\texttwosuperior{} $O(n\log n)$ до $O(n^2)$
      \\
      \hline
    \end{tabular}
  \end{center}
  1) В зависимости от выбранной последовательности интервалов.\\
  2) Лучший и худший случай~-- зависит от входных данных.
\end{slide}

\begin{slide}
  Сортировка вставками
  \begin{center}
    \renewcommand{\b}[1]{\textbf{#1}}
    \begin{tabular}{l|c|c|c|c|c|c|c|c|}
      \hhline{~|=|-------}
      1&	\b{6}&	5&	3&	1&      8&      7&      2&      4\\
      \hhline{~|=|-------}
      \multicolumn{9}{r}{}\\
      \hhline{~|==|------}
      2&	\b{5}&	6&	3&	1&      8&      7&      2&      4\\
      \hhline{~|==|------}
      \multicolumn{9}{r}{}\\
      \hhline{~|===|-----}
      3&	\b{3}&	5&	6&	1&      8&      7&      2&      4\\
      \hhline{~|===|-----}
      \multicolumn{9}{r}{}\\
      \hhline{~|====|----}
      4&	\b{1}&  3&	5&	6&	8&      7&      2&      4\\
      \hhline{~|====|----}
    \end{tabular}
    \qquad
    \begin{tabular}{l|c|c|c|c|c|c|c|c|}
      \hhline{~|=====|---}
        5&	1&	3&	5&	6&	\b{8}&	7&	2&	4\\
      \hhline{~|=====|---}
      \multicolumn{9}{r}{}\\
      \hhline{~|======|--}
        6&	1&	3&	5&	6&	\b{7}&	8&	2&	4\\
      \hhline{~|======|--}
      \multicolumn{9}{r}{}\\
      \hhline{~|=======|-}
      6&	1&	\b{2}&	3&	5&	6&	7&	8&	4\\
      \hhline{~|=======|-}
      \multicolumn{9}{r}{}\\
      \hhline{~|========|}
      8&	1&	2&	3&	\b{4}&	5&	6&	7&	8\\
      \hhline{~|========|}
    \end{tabular}
  \end{center}
  Массив длиной~$n$ делится на две секции: отсортированное начало длиной~$k$ и несортированный остаток.

  Инвариант цикла: элементы $0,\ldots,k-1$ отсортированы. Начальная истинность инварианта обеспечивается при~$k=0$.

  На каждой итерации взять первый элемент несортированной секции (элемент номер~$k$) и вставить его на правильное место
  сортированной секции. Увеличить~$k$ на~1.

  Когда~$k$ достигнет~$n$, весь массив отсортирован.
\end{slide}

\begin{slide}
  Пример реализации на языке C++

  \lstinputlisting[firstline=4]{insertion.h}
\end{slide}

\begin{slide}
  Анализ временной сложности
  \begin{itemize}
      \item Цикл совершает ровно~$n$ итераций. Необходимо каждый из~$n$ элементов переместить из несортированной части
        массива в отсортированную.
      \item В частности, в лучшем случае~-- если данные уже отсортированы~-- нужно~$n$ раз передвинуть границу между
        сортированным и несортированным сегментами.
      \item На каждой итерации цикла необходимо раздвинуть отсортированный сегмент для вставки элемента. В худшем случае
        (если элемент вставляется в начало массива) для этого требуется~$k$ операций, где~$k$ растёт в арифметической
        прогрессии от~$0$ до~$n-1$.
      \item Следовательно, временная сложность алгоритма составляет~$O(n^2)$ в среднем и худшем случае, в лучшем~-- $O(n)$.
  \end{itemize}
\end{slide}

\begin{slide}
  Сортировка выборками
  \begin{center}
    \renewcommand{\b}[1]{\textbf{#1}}
    \begin{tabular}{l|c|c|c|c|c|c|c|c|}
      \hhline{~|--------}
      1&	6&	5&	3&      \b{1}&  8&      7&      2&      4\\
      \hhline{~|--------}
      \multicolumn{9}{r}{}\\
      \hhline{~|=|-------}
      2&	1&      6&	5&	3&	8&      7&      \b{2}&  4\\
      \hhline{~|=|-------}
      \multicolumn{9}{r}{}\\
      \hhline{~|==|------}
      3&	1&      2&      6&	5&	\b{3}&	8&      7&      4\\
      \hhline{~|==|------}
      \multicolumn{9}{r}{}\\
      \hhline{~|===|-----}
      4&	1&      2&      3&	6&	5&	8&      7&      \b{4}\\
      \hhline{~|===|-----}
    \end{tabular}
    \qquad
    \begin{tabular}{l|c|c|c|c|c|c|c|c|}
      \hhline{~|====|----}
      5&	1&      2&      3&      4&	6&	\b{5}&	8&      7\\
      \hhline{~|====|----}
      \multicolumn{9}{r}{}\\
      \hhline{~|=====|---}
      6&	1&      2&      3&      4&	5&	\b{6}&	8&      7\\
      \hhline{~|=====|---}
      \multicolumn{9}{r}{}\\
      \hhline{~|======|--}
      7&	1&      2&      3&      4&	5&	6&	\b{7}&  8\\
      \hhline{~|======|--}
      \multicolumn{9}{r}{}\\
      \hhline{~|=======|-}
      8&	1&      2&      3&      4&	5&	6&	7&      \b{8}\\
      \hhline{~|=======|-}
    \end{tabular}
  \end{center}
  Массив длиной~$n$ делится на две секции: отсортированное начало длиной~$k$ и несортированный остаток.

  Инвариант цикла: элементы $0,\ldots,k-1$ отсортированы. Начальная истинность инварианта обеспечивается при~$k=0$.

  На каждой итерации взять наименьший элемент несортированной секции и вставить его в конец
  сортированной секции~-- на позицию~$k$. Увеличить~$k$ на~1.

  Когда~$k$ достигнет~$n$, весь массив отсортирован.
\end{slide}

\begin{slide}
  Пример реализации на языке C++
  \lstinputlisting[firstline=4]{selection.h}
\end{slide}

\begin{slide}
  Анализ временной сложности
  \begin{itemize}
    \item Цикл делает ровно~$n$ итераций, так как каждый элемент перемещает из несортированного сегмента в отсортированный.
    \item Вставка элемента в отсортированный сегмент требует~$O(1)$ времени, так как сводится к обмену значениями между
      элементом~$k$ и найденным наименьшим.
    \item На каждой итерации поиск наименьшего элемента среди несортированных требует~$O(n-k)$ времени,
      $k$~меняется в арифметической прогрессии от~0 до~$n-1$.
    \item Таким образом, временная сложность алгоритма составляет~$O(n^2)$, оценки для худшего, лучшего и среднего случаев
      совпадают.
    \item При этом число сравнений~$n^2-1$, число обменов~$n-1$.
  \end{itemize}
\end{slide}

\begin{slide}
  Пузырьковая сортировка
  \begin{center}
    \renewcommand{\b}[1]{\textbf{#1}}
    \begin{tabular}{l|c|c|c|c|c|}
      \hhline{~|-----}
      1&	\b{5}&  1&      4&      2&      8\\
      \hhline{~|-----}
      \multicolumn{6}{r}{}\\
      \hhline{~|-----}
      2&        1&      \b{5}&  4&      2&      8\\
      \hhline{~|-----}
      \multicolumn{6}{r}{}\\
      \hhline{~|-----}
      3&	1&      4&      \b{5}&  2&      8\\
      \hhline{~|-----}
      \multicolumn{6}{r}{}\\
      \hhline{~|-----}
      4&	1&      4&      2&      \b{5}&  8\\
      \hhline{~|-----}
    \end{tabular}
    \qquad
    \begin{tabular}{l|c|c|c|c|c|}
      \hhline{~|-----}
      5&	\b{1}&  4&      2&      5&      8\\
      \hhline{~|-----}
      \multicolumn{6}{r}{}\\
      \hhline{~|-----}
      6&        1&      \b{4}&  2&      5&      8\\
      \hhline{~|-----}
      \multicolumn{6}{r}{}\\
      \hhline{~|-----}
      7&        1&      2&      \b{4}&  5&      8\\
      \hhline{~|-----}
      \multicolumn{6}{r}{}\\
      \hhline{~|-----}
      8&        \b{1}&  2&      4&      5&      8\\
      \hhline{~|-----}
    \end{tabular}
  \end{center}
  Меньшие элементы массива постепенно перемещаются к его началу, подобно всплывающим пузырькам, большие элементы тонут~--
  перемещаются к концу.

  На каждом шаге алгоритм анализирует пару соседних элементов. Если $a_i>a_{i+1}$, их значения меняются местами, в обоих случаях
  $i$~наращивается на~1, т.е. алгоритм переходит к следующей паре.

  За первый проход алгоритм перемещает наибольший элемент в конец массива, за второй~-- наибольший из оставшихся ставит на
  предпоследнюю позицию и~т.д.
\end{slide}

\begin{slide}
  Пример реализации на языке C++
  \lstinputlisting[firstline=4]{bubble.h}
\end{slide}

\begin{slide}
  Анализ временной сложности
  \begin{itemize}
    \item Алгоритм содержит два вложенных цикла. Внешний цикл делает~$n-1$ итерацию, на $k$-й итерации внешнего циккла
      внутренний делает $n-1-k$ итарацию. Следовательно, общее число итераций внутреннего цикла (независимо от данных
      на входе) есть
      \[
        \frac{n\cdot(n-1)}{2} \in O(n^2)
      \]
    \item Число операций обмена в лучшем случае~0 (на вход подан предварительно отсортированный массив), в
      худшем~-- $n\cdot(n-1)/2$. 
    \item Обозначим через~$t(m)$, где~$m$~-- массив длины~$n$, количество таких пар $(i,j)$, что
      $0\leqslant i< j<n$ и $m_i>m_j$, т.е. общее количество нарушений порядка сортировки. Верхняя оценка до начала
      работы алгоритма $t\leqslant T=n\cdot(n-1)/2$. Каждое выполнение тела внутреннего цикла уменьшает~$T$ на~1.
  \end{itemize}
\end{slide}
\end{document}

